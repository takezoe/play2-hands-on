---
title: Implement User List View
---

Implement the user list view which displays all users in `USERS` table in ascending order.

## View

HTML templates need to be in `views` package. Create `views.user` package under app directory and create `list.scala.html` with following content:

```html
@* Parameter of this template *@
@(users: Seq[models.Users])(implicit request: RequestHeader)

@* Import helper to be used in this tamplate *@
@import helper._

@* Call main.scala.html *@
@main("User List") {

<div>
  <a href="@routes.UserController.edit()" class="btn btn-success" role="button">New User</a>
</div>

<div class="col-xs-6">
  <table class="table table-hover">
    <thead>
      <tr>
        <th>ID</th>
        <th>Name</th>
        <th>&nbsp;</th>
      </tr>
    </thead>
    <tbody>
    @users.map { user =>
      <tr>
        <td>@user.id</td>
        <td><a href="@routes.UserController.edit(Some(user.id))">@user.name</a></td>
        <td>@helper.form(CSRF(routes.UserController.remove(user.id))){
          <input type="submit" value="削除" class="btn btn-danger btn-xs"/>
        }
        </td>
      </tr>
    }
    </tbody>
  </table>
</div>

}
```

As you can see, there is `(implicit request: RequestHeader)` at the first line of the template. This is required to use `CSRF` helper in the template. In Play, CSRF protection filter is enabled in default. So you can use token based CSRF protection by only specifying `@helper.form(CSRF(...))` as the target of form submission. If you don't specify as that, you will see 403 error for form submission by CSRF protection.

> **POINT**
>
> * Declare parameters taken from controller at the first line of template
> * `@` allows to write Scala code in template
> * `@import` allows to write import statement. `@import helper._` means importing Play's default helper which offers functions like generating form, etc
> * `@*...*@` is comment
> * URL of links or forms can be reverse generated from routings  by `@routes.・・・`
> * Since CSRF protection filter is enabled in default, the target of form submission need to be surrounded by `CSRF(...)`

## Controller

`UserController`の`list`メソッドを以下のように実装します。

```scala
def list = Action { implicit request =>
  val u = Users.syntax("u")

  DB.readOnly { implicit session =>
    // ユーザのリストを取得
    val users = withSQL {
      select.from(Users as u).orderBy(u.id.asc)
    }.map(Users(u.resultName)).list.apply()

    // 一覧画面を表示
    Ok(views.html.user.list(users))
  }
}
```

`val u = Users.syntax("u")` is required for ScalikeJDBC's QueryDSL which allows to write SQL as type-safe. If you need to use this at several places in a same class, defining this as a field would be a good solution as below:

```scala
class UserController @Inject()(components: MessagesControllerComponents)
  extends MessagesAbstractController(components) {

  private val u = Users.syntax("u")

  ...
}
```

```scala
val users = withSQL {
  select.from(Users as u).orderBy(u.id.asc)
}.map(Users(u.resultName)).list.apply()
```

`select.from(Users as u).orderBy(u.id.asc)` in the above code is same as SQL below.

```sql
SELECT * FROM USERS ORDER BY ID
```

> **POINT**
>
> * Write controller logic in `Action { ... }`
>   * `implicit request` is necessary to use request implicitly in action
> * `Ok(views.html.・・・)` means responding HTML generated by specified template as the response
>   * Pass parameters to the template as arguments
> * In ScalikeJDBC, `DB.readOnly { ... }` allows to get a reference only session
>  * `withSQL { ... }` allows to use QueryDSL which offers type-safe DSL for SQL

## Run

When you finished implementing above things, access http://localhost:9000/user/list in your browser (If you didn't run `sbt run`, you need to run that). Then you will see the list of users as follows:

![User List View](../images/play2.6-scalikejdbc3.2/user_list.png)
